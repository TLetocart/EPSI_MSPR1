import tkinter as tk
from tkinter import ttk
import csv
import os
from tkinter import messagebox
import nmap
import socket
import getpass

# Fonction pour obtenir le nom de la machine à partir de l'adresse IP
def get_hostname_from_ip(ip):
    try:
        # Essayer d'obtenir le nom d'hôte à partir de l'adresse IP
        hostname = socket.gethostbyaddr(ip)[0]
        return hostname
    except socket.herror:
        return "Inconnu"  # Retourne "Inconnu" si le nom d'hôte n'est pas disponible

# Fonction pour scanner le réseau
def scan_network():
    scanner = nmap.PortScanner()
    ip_range = "10.60.12.0/22"  # Faut remplacer par la plage IP de l'environnement à scanner
    ports = "22,80,443"  # Les ports à scanner

    try:
        # Scanne le réseau
        result_label.config(text="Scan en cours, veuillez patienter...")
        scanner.scan(hosts=ip_range, ports=ports, arguments="-T4 -Pn")

        # Enregistrement en CSV
        filepath = "scan_results.csv"
        total_machines = 0

        with open(filepath, mode="w", newline='', encoding="utf-8") as file:
            csv_writer = csv.writer(file)
            csv_writer.writerow(["Adresse_IP", "Nom_Machine", "Ports"])  # Ajout de "Nom_Machine"

            for host in scanner.all_hosts():
                total_machines += 1
                port_states = []  # Liste pour stocker les ports et leurs états
                for port in [22, 80, 443]:  # On vérifie les ports spécifiques (22, 80, 443)
                    state = "closed"  # Par défaut, on assume que le port est fermé
                    if host in scanner.all_hosts() and port in scanner[host]["tcp"]:
                        state = scanner[host]["tcp"][port]["state"]
                    port_states.append(f"{port}: {state}")  # Ajouter l'état du port à la liste

                ports_states_str = ", ".join(port_states)  # Regrouper les ports et leurs états en une seule chaîne
                
                # Récupérer le nom de la machine via nmap ou socket
                try:
                    hostname = scanner[host].hostname()
                    if hostname == "":  # Si nmap ne trouve pas le nom, tenter avec socket
                        hostname = get_hostname_from_ip(host)
                except KeyError:
                    hostname = get_hostname_from_ip(host)  # Si nmap échoue, utiliser socket

                # Écrire les données avec le nom de la machine
                csv_writer.writerow([host, hostname, ports_states_str])

        # Afficher le nombre de machines trouvées
        nb_machine.config(text=f"Machines trouvées : {total_machines}")
        result_label.config(text=f"Scan terminé ! Résultats enregistrés dans 'scan_results.csv'. Total de machines : {total_machines}")

        load_csv()  # Charger les nouvelles données dans le tableau

    except Exception as e:
        messagebox.showerror("Erreur", f"Une erreur est survenue lors du scan :\n{e}")

# Fonction pour charger un fichier CSV et afficher les données dans le tableau
def load_csv():
    filepath = "scan_results.csv"
    try:
        # Charger les données depuis le fichier CSV
        with open(filepath, mode='r', encoding='utf-8') as file:
            csv_reader = csv.DictReader(file)
            
            # Vérifier les colonnes
            if "Adresse_IP" not in csv_reader.fieldnames or \
               "Nom_Machine" not in csv_reader.fieldnames or \
               "Ports" not in csv_reader.fieldnames:
                messagebox.showerror("Erreur", "Le fichier CSV ne contient pas les colonnes requises.")
                return

            # Supprime les anciennes données
            for row in tree.get_children():
                tree.delete(row)

            # Ajoute les nouvelles données au tableau
            for line in csv_reader:
                tree.insert("", tk.END, values=(line["Adresse_IP"], line["Nom_Machine"], line["Ports"]))  # Ajout de "Nom_Machine"

        result_label.config(text=f"Fichier chargé : {filepath}")

    except FileNotFoundError:
        messagebox.showerror("Erreur", f"Fichier introuvable : {filepath}")
    except Exception as e:
        messagebox.showerror("Erreur", f"Impossible de lire le fichier CSV.\n{e}")

# Création de la fenêtre principale
window = tk.Tk()
window.title("Seahawks Harvester")
window.geometry("600x500")

# Barre de titre
title_label = tk.Label(window, text="Seahawks Harvester 1.01", font=("Arial", 18, "bold"))
title_label.pack(pady=10)

# Section Résultats
result_label = tk.Label(window, text=f"Aucun fichier chargé.", font=("Arial", 12))
result_label.pack(pady=5)

# Nombre de machine
nb_machine = tk.Label(window, text="Aucune machine trouvée.", font=("Arial", 12))
nb_machine.pack(pady=5)

# Utilisateur
nom_user = tk.Label(window, text=f"Utilisateur : {getpass.getuser()} \nMachine : {socket.gethostname()} ", font=("Arial", 12))
nom_user.pack(pady=5)

# Tableau des résultats
columns = ("Adresse IP", "Nom Machine", "Ports")  
tree = ttk.Treeview(window, columns=columns, show="headings", height=8)
tree.heading("Adresse IP", text="Adresse IP")
tree.heading("Nom Machine", text="Nom Machine")
tree.heading("Ports", text="Ports")
tree.pack(pady=10)

# Boutons
scan_button = tk.Button(window, text="Scanner le réseau", command=scan_network)
scan_button.pack(pady=5)

load_button = tk.Button(window, text="Charger les données", command=load_csv)
load_button.pack(pady=5)

# Bas de page
footer_label = tk.Label(window, text="© Seahawks Monitoring, 2024", font=("Arial", 10))
footer_label.pack(side="bottom", pady=10)

# Lancer l'interface
window.mainloop()
